// ================================================================================================
//  workshop
//  Copyright (C) 2021 Tim Leonard
// ================================================================================================
#include "workshop.renderer/assets/shader/shader.h"
#include "workshop.render_interface/ri_interface.h"
#include "workshop.render_interface/ri_pipeline.h"
#include "workshop.renderer/renderer.h"
#include "workshop.renderer/render_effect.h"

namespace ws {

shader::shader(ri_interface& ri_interface, renderer& renderer)
    : m_ri_interface(ri_interface)
    , m_renderer(renderer)
{
}

shader::~shader()
{
    for (param_block& instance : param_blocks)
    {
        if (instance.renderer_id)
        {
            m_renderer.unregister_param_block_archetype(instance.renderer_id);
        }
    }

    for (effect& instance : effects)
    {
        if (instance.renderer_id)
        {
            m_renderer.unregister_effect(instance.renderer_id);
        }
    }
}

std::unique_ptr<ri_pipeline> shader::make_technique_pipeline(const technique& instance)
{
    ri_pipeline::create_params params;
    params.vertex_layout = vertex_layouts[instance.vertex_layout_index].layout;
    params.render_state = render_states[instance.render_state_index].state;

    output_target& target = output_targets[instance.output_target_index];
    params.depth_format = target.depth;
    params.color_formats = target.color;

    // Note: If you modify, update the auto-generated code 
    //       in shader_loader::create_autogenerated_stub.
    params.descriptor_tables.push_back(ri_descriptor_table::texture_1d);
    params.descriptor_tables.push_back(ri_descriptor_table::texture_2d);
    params.descriptor_tables.push_back(ri_descriptor_table::texture_3d);
    params.descriptor_tables.push_back(ri_descriptor_table::texture_cube);
    params.descriptor_tables.push_back(ri_descriptor_table::sampler);
    params.descriptor_tables.push_back(ri_descriptor_table::buffer);

    for (size_t block_index : instance.param_block_indices)
    {
        param_block& block = param_blocks[block_index];

        ri_param_block_archetype* archetype = m_renderer.get_param_block_archetype(block.renderer_id);
        db_assert(archetype != nullptr);

        params.param_block_archetypes.push_back(archetype);
    }

    for (size_t i = 0; i < instance.stages.size(); i++)
    {
        params.stages[i].bytecode = instance.stages[i].bytecode;
        params.stages[i].entry_point = instance.stages[i].entry_point;
        params.stages[i].file = instance.stages[i].file;
    }

    std::unique_ptr<ri_pipeline> pipeline = m_ri_interface.create_pipeline(params, instance.name.c_str());
    if (pipeline == nullptr)
    {
        db_error(asset, "Failed to create pipeline for technique '%s' in shader '%s'.", instance.name.c_str(), name.c_str());
        return nullptr;
    }

    return pipeline;
}

bool shader::post_load() 
{
    for (param_block& instance : param_blocks)
    {
        instance.renderer_id = m_renderer.register_param_block_archetype(instance.name.c_str(), instance.scope, instance.layout);
        if (instance.renderer_id == 0)
        {
            db_error(asset, "Failed to create param block archetype '%s' for shader '%s'.", instance.name.c_str(), name.c_str());
            return false;
        }
    }

    // Create render effect instances.
    for (effect& instance : effects)
    {
        std::unique_ptr<render_effect> effect = std::make_unique<render_effect>();
        effect->name = instance.name;

        for (effect::technique& instance : instance.techniques)
        {
            render_effect::technique& tech = effect->techniques.emplace_back();
            tech.name = instance.name;
            
            for (variation& var : instance.variations)
            {
                render_effect::variation_parameter& param = tech.variation_parameters.emplace_back();
                param.name = var.name;
                param.values = var.values;
            }

            auto iter = std::find_if(techniques.begin(), techniques.end(), [&instance](const technique& value) {
                return value.name == instance.name;
            });

            if (iter == techniques.end())
            {
                db_fatal(asset, "Failed to find appropriate technique data for effect technique. This shouldn't be possible, check shader_loader for bugs!");
                return false;
            }

            tech.pipeline = make_technique_pipeline(*iter);
        }

        instance.renderer_id = m_renderer.register_effect(std::move(effect));
    }

    return true;
}

}; // namespace ws
